# -*- coding: utf-8 -*-
"""422LAB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ddV0jzBG3opY4f0AmqVqQxZohl01ucJk

LAB 1
"""

import heapq

def read_input(file_input):
    f_in=open(file_input,'r')
    lines=f_in.readlines()

    heuristic_values ={}
    graph ={}

    for i in lines:
        parts = i.split()
        city,heuristic,*neighbors=parts
        heuristic_values[city]=int(heuristic)
        graph[city]={neighbors[i]:int(neighbors[i+1]) for i in range(0, len(neighbors),2)}

    return graph,heuristic_values

def a_star_search(graph, heuristic_values, start, goal):
    open_list = []
    heapq.heappush(open_list, (heuristic_values[start], 0, start, [start]))
    visited = set()
    while open_list:
        priority, cost, current, path = heapq.heappop(open_list)

        if current == goal:
            return path, cost
        if current in visited:
            continue
        visited.add(current)

        for neighbor, distance in graph[current].items():
            if neighbor not in visited:
                total_cost = cost + distance
                heapq.heappush(open_list, (total_cost + heuristic_values[neighbor], total_cost, neighbor, path + [neighbor]))

    return None

file_input = "/content/Input file (lab1).txt"
graph,heuristic_values=read_input(file_input)

start_node=input("Start node:: ")
goal_node=input("Destination node:: ")
result=a_star_search(graph, heuristic_values, start_node, goal_node)

if result:
    path, total_dist = result
    print(f"Path: {' -> '.join(path)}")
    print(f"Total Distance: {total_dist} km")
else:
    print("NO PATH FOUND")

"""Lab 2"""

import random

file_input = open("/content/Input file(lab2).txt", "r")

#C=initial chromosomes
#G=generations
C,G = map(int, file_input.readline().strip().split())

capital = float(file_input.readline().strip()) # Capital to Start With
historical_prices = list(map(float, file_input.readline().strip().split()))

# initial population
population = []
for i in range(C):
    sl, tp, ts = map(float, file_input.readline().strip().split())
    population.append({"stop_loss": sl, "take_profit": tp, "trade_size": ts})

file_input.close()


len_of_chromosome = 3
def chromosome():
    return {
        "stop_loss": round(random.uniform(1, 10), 1),
        "take_profit": round(random.uniform(1, 10), 1),
        "trade_size": round(random.uniform(5, 30), 1)
    }

def population_creation(size=G):
    return [chromosome() for i in range(size)]

def parentSelection():
    return random.sample(population, 2)

def crossover():
    parent1, parent2 = parentSelection()
    crossover_point = random.choice(["stop_loss", "take_profit", "trade_size"])

    child1, child2 = parent1.copy(), parent2.copy()
    child1[crossover_point], child2[crossover_point] = parent2[crossover_point], parent1[crossover_point]

    return child1, child2

def mutation(offspring, mutation_prob=0.1):
    mutated_offspring = offspring.copy()

    for gene in ["stop_loss", "take_profit", "trade_size"]:
        if random.random() < mutation_prob:
            if gene == "stop_loss":
                mutated_offspring[gene] += round(random.uniform(-1, 1), 1)
                mutated_offspring[gene] = max(1, min(10, mutated_offspring[gene]))

            elif gene == "take_profit":
                mutated_offspring[gene] += round(random.uniform(-1, 1), 1)
                mutated_offspring[gene] = max(1, min(10, mutated_offspring[gene]))

            else:  # Trade size
                mutated_offspring[gene] += round(random.uniform(-2, 2), 1)
                mutated_offspring[gene] = max(5, min(30, mutated_offspring[gene]))

    return mutated_offspring

def fitness(strategy):
    current_capital=capital
    trade_size=strategy["trade_size"]/100

    for price_change in historical_prices:
        trade_amount=current_capital*trade_size

        # Apply stop-loss
        if price_change<-strategy["stop_loss"]:
            loss=trade_amount*(strategy["stop_loss"]/100)
            current_capital -= loss
        # Apply take-profit
        elif price_change>strategy["take_profit"]:
            profit=trade_amount*(strategy["take_profit"]/100)
            current_capital+=profit
        else:
            # Normal trade gain/loss
            profit_or_loss=trade_amount*(price_change/100)
            current_capital+=profit_or_loss

    return current_capital - capital


best_fitness = []
best_mutation = []

for _ in range(G):
    c1, c2 = crossover()
    fit1 = fitness(c1)
    fit2 = fitness(c2)


    if fit1 > fit2: #offspring
        best_offspring = c1
        best_fit = fit1
    else:
        best_offspring = c2
        best_fit = fit2


    best_mutation.append(best_offspring)
    best_fitness.append(best_fit)
    if best_fit == 0:
        break

max_fit = max(best_fitness)
max_mutation = best_mutation[best_fitness.index(max_fit)]

print(f"best_strategy: {max_mutation}")
print(f"Final Profit: {max_fit}")

# TASK 02:

def twoPointCrossover(parent1, parent2):
    genes = list(parent1.keys())

    cp1, cp2 = sorted(random.sample(range(len(genes)), 2))
    child1, child2 = parent1.copy(), parent2.copy()

    for i in range(cp1, cp2 + 1):
        gene = genes[i]
        child1[gene], child2[gene] = child2[gene], child1[gene]

    return child1, child2

parent1, parent2 = parentSelection()
offspring1, offspring2 = twoPointCrossover(parent1, parent2)

print("Offspring 1 (Two-Point Crossover):", offspring1)
print("Offspring 2 (Two-Point Crossover):", offspring2)

"""Lab 3

"""

#problem1
import random
import math

def strength(x):
    return math.log2(x +1)+ x/10

def utilityfunc(maxV, minV, i):
    i = random.randint(0, 1)
    return strength(maxV) - strength(minV) + ((-1)**i )* random.randint(1, 10) / 10

def gameresult(depth, is_max, maxV, minV, alpha, beta):
    if depth == 0:
        return utilityfunc(maxV, minV, random.randint(0, 1))

    if is_max:
        maximize = float('-inf')
        for i in range(2):
            eval = gameresult(depth - 1, False, maxV, minV, alpha, beta)
            maximize = max(maximize, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return maximize
    else:
        minimize = float('inf')
        for i in range(2):
            eval = gameresult(depth - 1, True, maxV, minV, alpha, beta)
            minimize = min(minimize, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return minimize

def play_game(starting_player, maxV, minV):
    if starting_player == 0:  # Carlsen as Max
        win_val = gameresult(5, True, maxV, minV, float('-inf'), float('inf'))
    else:  # Caruana as Max
        win_val = gameresult(5, True, minV, maxV, float('-inf'), float('inf'))

    if win_val > 0:
        return "Magnus Carlsen (Max)", win_val
    elif win_val < 0:
        return "Fabiano Caruana (Min)", win_val
    else:
        return "Draw", win_val

games = 4
carlsen_wins = 0
caruana_wins = 0
draws = 0

starting_player = int(input("Enter starting player for game 1 (0 for Carlsen, 1 for Caruana): "))
maxV = int(input("Enter base strength for Carlsen: "))
minV = int(input("Enter base strength for Caruana: "))


for game in range(4):

    winner, utility_value = play_game(starting_player, maxV, minV)
    print(f"Game {game + 1} Winner: {winner} (Utility value: {utility_value:.2f})")

    if "Magnus Carlsen" in winner:
        carlsen_wins += 1
    elif "Fabiano Caruana" in winner:
        caruana_wins += 1
    else:
        draws += 1

    starting_player = 1 - starting_player  # Switching between 0 and 1

print(f"Overall Results: Magnus Carlsen Wins: {carlsen_wins}, Fabiano Caruana Wins: {caruana_wins}, Draws: {draws}")
if carlsen_wins > caruana_wins:
    print("Overall Winner: Magnus Carlsen")
elif caruana_wins > carlsen_wins:
    print("Overall Winner: Fabiano Caruana")
else:
    print("Overall Winner: Draw")

#problem2
import math
import random

def strength(x):
    return math.log2(x + 1) + x / 10

def gameresult(max_strength, min_strength, depth, maximizing, mind_control_cost=0):
    if depth == 0:
        return strength(max_strength) - strength(min_strength)

    if maximizing:
        best_value = float('-inf')
        for i in range(2):
            value = gameresult(max_strength, min_strength, depth - 1, False)
            best_value = max(best_value, value)
        return best_value
    else:
        best_value = float('inf')
        for i in range(2):
            value = gameresult(max_strength, min_strength, depth - 1, True)
            best_value = min(best_value, value)
        return best_value

def minimax_with_mind_control(max_strength, min_strength, depth, mind_control_cost):
    without_mind_control = gameresult(max_strength, min_strength, depth, True)
    with_mind_control = gameresult(max_strength, min_strength, depth, True) - mind_control_cost
    return without_mind_control, with_mind_control

player1 = int(input("Enter who goes first (0 for Light, 1 for L): "))
mc_cost = float(input("Enter the cost of using Mind Control: "))
light_strength = float(input("Enter base strength for Light: "))
l_strength = float(input("Enter base strength for L: "))

minimax_value_without_mind_control, minimax_value_with_mind_control = minimax_with_mind_control(light_strength, l_strength, 5, mc_cost)
minimax_value_with_mind_control_after_cost = minimax_value_with_mind_control


print(f"Minimax value without Mind Control: {minimax_value_without_mind_control:.2f}")
print(f"Minimax value with Mind Control: {minimax_value_with_mind_control:.2f}")
print(f"Minimax value with Mind Control after incurring the cost: {minimax_value_with_mind_control_after_cost:.2f}")

#Decision
if player1 == 0:  # Light goes first
    if minimax_value_without_mind_control > 0:
        print("Light should NOT use Mind Control as the position is already winning.")
    elif minimax_value_with_mind_control > 0:
        print("Light should use Mind Control.")
    else:
        print("Light should NOT use Mind Control as the position is losing either way.")
else:  # L goes first
    if minimax_value_without_mind_control < 0:
        print("L should NOT use Mind Control as the position is already winning.")
    elif minimax_value_with_mind_control < 0:
        print("L should use Mind Control.")
    else:
        print("L should NOT use Mind Control as the position is losing either way.")